Criação de um Script de Teste com Maven e Selenium

Abri o STS e escolhi File > New > Maven project. Marquei a opção Create a Simple Project. Escrevi com.sheilagomes em GroupID e testes.web.multitude em ArtifactID. Abri o arquivo pom.xml do projeto. No site mvnrepository.com procurei as dependências do Junit Jupiter (Aggregator), Hamcrest e Selenium Java, selecionando as versões mais atualizadas que não eram alpha. Copiei o código das dependências no pom. Para facilitar futuras atualizações acrescentei uma tag <properties> com as versões das dependências e, dentro das dependências, usei as tags ${junit.version}, ${hamcrest.version} e ${selenium.version} para referenciar. Cliquei no JRE System Library dentro do projeto e depois em Properties para alterar a versão do JRE que está sendo usada. Em src/test/java criei um pacote base e outro homepage. No pacote homepage criei a classe HomepageTests. Dentro dela, criei a primeira anotação @Test com um método público sem retorno chamado testContarProdutos_oitoProdutosDiferentes(). Dentro dele, chamei o método carregarPaginaInicial() e a asserção assertThat(homepage.contarProdutos(), is(8));
Então fiz o apontamento para o WebDriver e para isso criei a classe BaseTests, que será referenciada para herança dentro de HomepageTests. Em BaseTests criei uma variável privada do tipo WebDriver chamada driver e uma variável protegida do tipo Homepage chamada homepage. Criei então uma anotação @BeforeAll com um método público estático e sem retorno chamado inicializar(), e dentro dele defini a propriedade de system com uma variável webdriver.chrome.driver com o valor do caminho do driver do chrome no meu computador: "/home/sheila/chromedriver/chromedriver". Daí inicializei a variável driver com o nome ChromeDriver(). Criei então uma anotação @BeforeEach com um método público e sem retorno chamado carregarPaginaInicial(). Dentro dele chamei a página "https://marcelodebittencourt.com/demoprestashop/" com driver.get. 
Daí inicializei a variável homepage com o nome Homepage e parâmetro driver. Criei a anotação @AfterAll com um método público estático e sem retorno chamado finalizar() e dentro dele chamei driver com o método quit() para fechar a página.
Em src/main/java criei o pacote pages e dentro dele a classe Homepage. Nela criei uma variável privada do tipo WebDriver chamada driver e um construtor com esta variável. Criei então um método público com retorno int chamado contarProdutos() e dentro dele chamo o método carregarListaProdutos() e retorno listaProdutos.size(). Inicializei a variável  ArrayList<WebElement>() do tipo List<WebElement> listaProdutos acima do primeiro método. Criei um método privado sem retorno chamado carregarListaProdutos(). Precisei localizar os elementos na página com a inspeção do developer tools. Acrescentei então o apontamento do elemento procurado em Homepage.java, antes dos métodos, como uma variável privada do tipo By chamada produtos igual a By.xpath("//img[contains(@class,'size-thumbnail wp-image-3214 alignright')]") usando a extensão ChroPath do Firefox. No método carregarListaProdutos() fiz a busca dos elementos na paǵina com o método findElements e o parametro produtos no driver. Fui então na classe HomepageTests para testar se estava funcionando, clicando duas vezes em testContarProdutos_oitoProdutosDiferentes() e clicando com o botão direito escolho Run as > Junit para testar. Tudo rodou como devia.

Confirmar que o Carrinho de Compras está Vazio

Fui então ao segundo teste, criei a anotação @Test com um método público sem retorno chamado  testValidarCarrinhoZerado_ZeroItensNoCarrinho().
Criei então uma variável do tipo int chamada produtosNoCarrinho atribuído a um método homepage.obterQuantidadeProdutosNoCarrinho().
Na respectiva página do site, seleciono o elemento que contém o número de produtos no carrinho ("cart-products-count") e volto ao código. Na classe Homepage crio então o apontamento ao elemento, uma variável privada to tipo By chamada textoProdutosNoCarrinho e atribuída a By.className("cart-products-count"). Crio então o método público com retorno int chamado  obterQuantidadeProdutosNoCarrinho(). Dentro dele, extraio o texto do apontamento com driver.findElement(textoProdutosNoCarrinho).getText() e atribuo a uma variável  quantidadeProdutosNoCarrinho do tipo String. Como o texto vem com parênteses, preciso removê-los, usando o método replace em cima da variável quantidadeProdutosNoCarrinho, uma vez para tirar o parênteses inicial, outra para o final.
Agora converto a variável quantidadeProdutosNoCarrinho do tipo String  criando uma variável qtdProdutosNoCarrinho do tipo int e usando o método Integer.parseInt. Esta última variável será o retorno do método 
obterQuantidadeProdutosNoCarrinho().
Em HomePageTests faço então a asserção do teste testValidarCarrinhoZerado_ZeroItensNoCarrinho() para confirmar que o número de produtos no carrinho é 0.

Testar o fluxo padrão - Parte 1

Crio então o terceiro teste, usando a anotação @Test com um método público sem retorno chamado testValidarDetalhesDoProduto_DescricaoEValorIguais(). Dentro dele crio uma variável chamada indice do tipo int que atribuo a 0, equivalente ao índice do primeiro produto da página que será percorrida. Crio então uma variável do tipo String chamada nomeProduto_HomePage equivalente ao método obterNomeProduto(indice) da classe homePage e outra variável do tipo String chamada precoProduto_HomePage equivalente ao método obterPrecoProduto(indice) da classe homePage. Na classe Homepage crio então os dois métodos públicos com retorno de String chamados obterNomeProduto(int indice) e obterPrecoProduto(int indice). O retorno dos dois métodos é driver.findElements(descricoesDosProdutos).get(indice).getText() e driver.findElements(precoDosProdutos).get(indice).getText(), que extrai o texto do índice indicado de acordo com a respectiva variável. Para os métodos funcionarem é preciso criar variáveis acima dos métodos na classe Homepage, depois de descobrir no site qual é o seletor css de cada uma. A primeira variável é privada do tipo By e se chama descricoesDosProdutos, encontrada pelo seletor By.cssSelector(".product-description a").
A segunda é também é é privada do tipo By e se chama descricoesDosProdutos, encontrada pelo seletor By.className("price"). Esse apontamento terá que ser clicado e pra isso crio um método homePage.clicarProduto(indice) atribuído a um Page Object para a nova página. Na classe Homepage crio então o método público, com retorno de um novo tipo ProdutoPage, chamado clicarProduto(int indice). Nesse método obtenho o índice desejado e aciono o clique com driver.findElements(descricoesDosProdutos).get(indice).click().
Crio então a classe ProdutoPage no pacote pages que será responsável pelo novo objeto a ser aberto, ou seja, a nova página. Na classe ProdutoPage criei uma variável privada do tipo WebDriver chamada driver e um construtor com ela, para poder interagir com a classe mantendo o apontamento aparecendo no navegador. Em HomePageTests crio duas variáveis do tipo String chamadas nomeProduto_Produto e precoProduto_ProdutoPage, que atribuo respectivamente aos métodos produtoPage.obterNomeProduto() e produtoPage.obterPrecoProduto(). Importo então a classe ProdutoPage já criada. Mando imprimir no console as duas variáveis criadas. Inspeciono então na página nova quais são as classes dos elementos que preciso testar. Daí, em ProdutoPage crio o apontamento ao elemento com duas variáveis privadas do tipo By chamadas nomeProduto e precoProduto, atribuídas respectivamente a By.className("h1") e By.cssSelector(".current-price span:nth-child(1)").
Em ProdutoPage crio então os métodos públicos com retorno do tipo String chamados obterNomeProduto() e obterPrecoProduto()
que retornam respectivamente driver.findElement(nomeProduto).getText() e driver.findElement(precoProduto).getText(). 
Finalmente, em HomePageTests
incluo as asserções com assertThat para comparar as variáveis esperadas e o resultado encontrados na página. Para garantir que a forma não interfira no conteúdo, uso o método toUpperCase() no final das duas partes na primeira asserção.

Testar Login

Para testar o login na página https://marcelodebittencourt.com/demoprestashop/ primeiro crio um usuário sheila@teste.com com a senha sheila só para teste. Em HomePageTests crio um novo teste com a anotação @Test com um método público sem retorno chamado testLoginComSucesso_UsuarioLogado(). O método deve conter quatro passos: clicar no botão Sign in na página inicial, preencher usuário e senha, clicar no botão Sign in para entrar e validar se o usuário está mesmo conectado. Para o primeiro passo, na classe HomePage fiz o apontamento ao elemento depois de inspecionar a página, criando uma variável privada do tipo By chamada botaoSignIn e atribuída a By.cssSelector("#_desktop_user_info span.hidden-sm-down"). Crio também um método público com retorno do tipo LoginPage chamado clicarBotaoSignIn() para clicar o elemento.
Dentro dele, crio a ação do clique com driver.findElement(botaoSignIn).click() e o retorno terá driver como parâmetro. Crio então a classe LoginPage no pacote pages.
Dentro dela criei uma variável privada do tipo WebDriver chamada driver e um construtor com ela, para poder interagir com a classe mantendo o apontamento aparecendo no navegador. Na página de login do site inspeciono os elementos que vou precisar mapear: o e-mail, a senha e o botão Sign in.
Na classe LoginPage crio o apontamento com as variáveis privadas do tipo By chamadas email, password e botaoSignIn, atribuídas respectivamente a By.name("email"), By.name("password") e  By.id("submit-login").
Crio então os métodos para preencher os campos e clicar no botão. O primeiro método é público e sem retorno, chamado preencherEmail com parâmetro texto do tipo String que preencherá o e-mail com 	driver.findElement(email).sendKeys(texto). O segundo método também é público e sem retorno, chamado preencherPassword com parâmetro texto do tipo String que preencherá a senha com driver.findElement(password).sendKeys(texto). O terceiro método também é público e sem retorno, chamado clicarBotaoSignIn() que clicará no botão com 	driver.findElement(botaoSignIn).click().
Volto então à classe HomePageTests para implementar os métodos no teste. Crio a variável loginPage do tipo LoginPage atribuída a homePage.clicarBotaoSignIn() para entrar na página de login. Preencho o campo de e-mail com 		loginPage.preencherEmail("sheila@teste.com") e o de senha com loginPage.preencherPassword("sheila"), aí clico no botão Sign in com loginPage.clicarBotaoSignIn(). Mapeio na página o elemento que indica que o usuário entrou e incluo o mapeamento na classe HomePage com a variável privada do tipo By chamada usuarioLogado e atribuída a  By.cssSelector("#_desktop_user_info span.hidden-sm-down"). Crio também o método público do tipo boolean chamado estaLogado com o parâmetro texto do tipo String que verifica se o usuário entrou com  texto.contentEquals(driver.findElement(usuarioLogado).getText()).
Em HomePageTests crio a asserção para validar a entrada do usuário com assertThat(homePage.estaLogado("Sheila Gomes"), is(true)). Finalmente, chamo o método carregarPaginaInicial() que vem de BaseTests para que o site volte ao início depois do login.

Testar o Fluxo Padrão - Parte 2

Em HomePageTests crio um novo teste usando a anotação @Test com um método público sem retorno chamado  incluirProdutoNoCarrinho_ProdutoIncluidoComSucesso(). Dentro dele, verifico se o usuário entrou, e caso não tenha entrado, uso uma condicional if (!homePage.estaLogado("Sheila Gomes")) rodando o método testLoginComSucesso_UsuarioLogado() para entrar. Aí testo se, ao clicar no produto, a página de detalhes é carregada, com testValidarDetalhesDoProduto_DescricaoEValorIguais(). Em ProdutoPage incluo uma variável privada do tipo By chamada tamanhoProduto já mapeada na página como By.id("group_1"). Incluo também um método público do tipo Select chamado encontrarDropdownSize() que retorna um novo  Select(driver.findElement(tamanhoProduto)).

Testar o Fluxo Padrão - Parte 3

Ainda em ProdutoPage incluo o método público do tipo List<String> chamado obterOpcoesSelecionadas() para processar as opções encontradas pelo método encontrarDropdownSize(). Crio uma variável do tipo List<WebElement> chamada elementosSelecionados atribuída a  encontrarDropdownSize().getAllSelectedOptions() para obter todas opções. Crio também uma variável do tipo List<String> chamada listaOpcoesSelecionadas com um novo ArrayList() para armazenar o texto das opções. Percorro os elementos com o laço for (WebElement elemento : elementosSelecionados) para adicioná-los ao array criado com listaOpcoesSelecionadas.add(elemento.getText()). No final o método retorna o conteúdo da lista listaOpcoesSelecionadas.
Para selecionar a opção desejada no dropdown, crio um método públic sem retorno com um parâmetro chamado  selecionarOpcaoDropDown(String opcao) que vai selecionar o texto e atribuí-lo à variável opcao com encontrarDropdownSize().selectByVisibleText(opcao) de acordo com a opção que estiver selecionada na página. Em HomePageTests, coloco as instanciacões do tipo LoginPage loginPage e ProdutoPage produtoPage fora dos testes, para poder usá-las de forma mais abrangente. No teste incluirProdutoNoCarrinho_ProdutoIncluidoComSucesso() incluo a variável do tipo List<String> chamada listaOpcoes e atribuo a  produtoPage.obterOpcoesSelecionadas(). Mando imprimir no console a primeira opção selecionada e o tamanho da lista com System.out.println(listaOpcoes.get(0)) e System.out.println("Tamanho da lista: " + listaOpcoes.size()). Para selecionar a opção desejada uso produtoPage.selecionarOpcaoDropDown(tamanhoProduto). E para obter a lista de produto com a opção desejada seecionada uso listaOpcoes = produtoPage.obterOpcoesSelecionadas() e mando imprimir no console da mesma forma que antes, com System.out.println(listaOpcoes.get(0)) e System.out.println("Tamanho da lista: " + listaOpcoes.size()). Para selecionar a cor, inspecionei a página e mapeio o elemento usando xpath com o ChroPath. Em ProdutoPage incluo uma variável privada do tipo By chamada inputCorPreta e atribuída a By.xpath("/html[1]/body[1]/main[1]/section[1]/div[1]/div[1]/section[1]/div[1]/div[2]/div[2]/div[2]/form[1]/div[1]/div[2]/ul[1]/li[2]/label[1]/input[1]").
Na mesma classe criei então o método público sem retorno chamado selecionarCorPreta() para atribuir um clique à cor desejada com 	driver.findElement(inputCorPreta).click(). Em HomePageTests, no teste incluirProdutoNoCarrinho_ProdutoIncluidoComSucesso() incluo a chamada do método produtoPage.selecionarCorPreta(). Para referenciar a quantidade desejada no site, volto à página e mapeio o elemento. Em ProdutoPage, crio uma variável privada do tipo By chamada quantidadeProduto atribuída a By.id("quantity_wanted"). Crio também um método público sem retorno com um parâmetro chamado alterarQuantidade(int quantidade). Dentro dele, primeiro localizo e limpo o elemento com driver.findElement(quantidadeProduto).clear() e depois atribuo a quantidade com driver.findElement(quantidadeProduto).sendKeys(Integer.toString(quantidade)).
Em HomePageTests chamo o método
produtoPage.alterarQuantidade(quantidadeProduto) no teste incluirProdutoNoCarrinho_ProdutoIncluidoComSucesso(). 
Finalmente, para referenciar o botão Add to cart no site, volto à página e mapeio o elemento. Em ProdutoPage, crio uma variável privada do tipo By chamada botaoAddToCart  atribuída a By.className("add-to-cart"). Crio também um método público do tipo  ModalProdutoPage chamado clicarBotaoAddToCart(). Dentro dele localizo e clico o elemento com 	driver.findElement(botaoAddToCart).click() e retorno um novo ModalProdutoPage(driver).

Teste do Fluxo Padrão - Parte 4

Crio uma nova classe ModalProdutoPage no pacote pages. Dentro dela, crio uma variável privada do tipo WebDriver chamada driver
e um construtor com ela. Na página de modal do site inspeciono o elemento para mapeá-lo. Volto a ModalProdutoPage e adiciono uma variável privada do tipo By chamada  mensagemProdutoAdicionado e atribuída a By.id("myModalLabel"). Crio então um método público chamado  obterMensagemProdutoAdicionado() que retona uma String com driver.findElement(mensagemProdutoAdicionado).getText().  
Em HomePageTests, no teste incluirProdutoNoCarrinho_ProdutoIncluidoComSucesso() instancio modalProdutoPage e atribuo a chamada do método produtoPage.clicarBotaoAddToCart(), além de importar a nova classe. Para validar se o texto resultante está correto, faço uma asserção com
assertThat, com resultado esperado de  modalProdutoPage.obterMensagemProdutoAdicionado()
				.endsWith("Product successfully added to your shopping cart") e resultante is(true). Para não ter problema de sincronia por carregamento mais rápido que o da emissão da mensagem, em ModalProdutoPage, dentro do método obterMensagemProdutoAdicionado() acrescento uma variável de espera do tipo FluentWait (uma classe do Selenium) chamada wait que instancia uma nova espera de 5 segundos e ignora a exceção que aparece por conta da falta de sincronia usando  FluentWait(driver).withTimeout(Duration.ofSeconds(5)).pollingEvery(Duration.ofSeconds(1)).ignoring(NoSuchElementException.class).
Importo a classe FluentWait e chamo o método wait.until(ExpectedConditions.visibilityOfElementLocated(mensagemProdutoAdicionado)) para estabelecer as condições da espera.

Testar o Fluxo Padrão - Parte 5

Em HomePageTests, no início do teste incluirProdutoNoCarrinho_ProdutoIncluidoComSucesso(), crio a variável do tipo String chamada tamanhoProduto atribuída a "M", a variável do tipo String chamada corProduto atribuída a "Black" e a variável do tipo int chamada  quantidadeProduto atribuída a 2.

Testar o Fluxo Padrão - Parte 6

Depois de inspecionar a página para mapear o elemento, vou a ModalProdutoPage e crio as variáveis privadas do tipo By chamadas e atribuídas respectivamente a descricaoProduto e By.className("product-name"), precoProduto e By.cssSelector("div.modal-body p.product-price"), listaValoresInformados e By.cssSelector("div.divide-right .col-md-6:nth-child(2) span strong"), esta última para os três valores finais necessários. Crio então o método públic obterTamanhoProduto() que retorna uma String com driver.findElements(listaValoresInformados).get(0).getText(). Faço o mesmo com a cor e quantidade, criando os métodos públicos obterCorProduto() e  obterQuantidadeProduto() que retornam as Strings driver.findElements(listaValoresInformados).get(1).getText() e driver.findElements(listaValoresInformados).get(2).getText().

Testar o Fluxo Padrão - Parte 7

Em HomePageTests, no teste incluirProdutoNoCarrinho_ProdutoIncluidoComSucesso(), crio três asserções para validar tamanho, cor e quantidade do produto no modal. Com assertThat, valido os resultados esperados e obtidos respectivamente com modalProdutoPage.obterTamanhoProduto() e  is(tamanhoProduto)), modalProdutoPage.obterCorProduto() e  is(corProduto)) e modalProdutoPage.obterQuantidadeProduto() e  is(Integer.toString(quantidadeProduto))). Na página, mapeio o elemento que representa o subtotal do carrinho. Em ModalProdutoPage crio uma variável privada do tipo By chamada subtotal atribuída a By.cssSelector(".cart-content p:nth-child(2) span.value"). Crio também um método público chamado obterSubtotal() que retorna uma String com driver.findElement(subtotal).getText(). Adiciono também os métodos públicos obterDescricaoProduto() e obterPrecoProduto(),
que retornam Strings com driver.findElement(descricaoProduto).getText() e driver.findElement(precoProduto).getText().
Em HomePageTests, no teste incluirProdutoNoCarrinho_ProdutoIncluidoComSucesso(), acima das 3 asserções criadas, crio uma variável do tipo String chamada precoProdutoString e atribuída a modalProdutoPage.obterPrecoProduto(). Em seguida converto o formato da variável com  precoProdutoString.replace("$", ""). E crio outra variável do tipo Double chamada precoProduto atribuída a  Double.parseDouble(precoProdutoString). Aproveito as mesmas variáveis e conversão abaixo das asserções, substituindo precoProduto por subtotal. Aí crio uma variável para calcular o subtotal do tipo Double chamada subtotalCalculado e atribuída a quantidadeProduto * precoProduto. Crio então a asserção para validar essa [última operação, com um assertThat(subtotal, is(subtotalCalculado)). A última vaidação que falta é a da descrição do produto, que é feita abaixo da validação da mensagem do modal com um assertThat, resultado esperado de  modalProdutoPage.obterDescricaoProduto().toUpperCase() e obtido de  is(nomeProduto_ProdutoPage.toUpperCase())).

Testar Ir para o Carrinho - Parte 1

Em HomepageTests criei mais uma anotação @Test com um método público sem retorno chamado IrParaCarrinho_InformacoesPersistidas(). Chamo o teste incluirProdutoNoCarrinho_ProdutoIncluidoComSucesso() para entrar no modal. Extraí então a referência a ModalProdutoPage modalProdutoPage de dentro do teste anterior para poder aproveitá-la nos outros testes. No teste IrParaCarrinho_InformacoesPersistidas() criei uma variável do tipo CarrinhoPage chamada carrinhoPage que atribuí ao método  modalProdutoPage.clicarBotaoProceedToCheckout(). Depois de inspecionar o site, em ModalProdutoPage, crio uma variável privada do tipo By chamada botaoProceedToCheckout e atribuída a By.cssSelector("div.cart-content-btn a.btn-primary"). Também crio o método público do tipo CarrinhoPage chamado clicarBotaoProceedToCheckout() com driver.findElement(botaoProceedToCheckout).click() que retorna um novo CarrinhoPage(driver). 
Crio então uma nova classe no pacote pages chamada CarrinhoPage. Dentro dela crio a variável privada do tipo WebDriver chamada driver e o construtor dela. Em HomepageTests importo a classe CarrinhoPage.

Testar Ir para o Carrinho - Parte 2

Como nesta parte vamos lidar com telas contendo muitos campos, para facilitar o mapeamento de elementos, vamos usar code snippets. Em CarrinhoPage crio a variável privada do tipo By chamada nomeProduto atribuída a By.cssSelector("div.product-line-info a"). Na IDE clico em Window > Show View > Other e busco snippet, clico em Snippets e Ok. Uma subtela abrirá embaixo do editor, clico dentro dela com o botão direito e escolho Customize. Clico em New > New Category e chamo a categoria de Variáveis. Clico na nova categoria e escolho New Item, chamo de Nova variável By e copio o snippet private By nomeProduto = By.cssSelector("div.product-line-info a"); na seção Template, removendo o que será substituído e deixando private By nomeProduto = By ("");. Em Variables clico em New e nomeio a variável que será o placeholder. Em Template, no local onde a variável será inserida, posiciono o cursor e clico em Insert Variable Placeholder, escolhendo a variável que acabei de criar em cima. Clico em Ok. Para usar os snippets, posiciono o cursor no código, clico uma vez em Variáveis na subtela e em Nova variável By duas vezes. Na tela que abre, clico em Value e digito o nome desejado para a variável.
Mapeio então os elementos desejadas na página e acrescento em CarrinhoPage mais uma variável privada do tipo By chamada precoProduto e atribuída a By.cssSelector("span.price").

Testar Ir para o Carrinho - Parte 3

Depois de mapear os elementos desejados, em CarrinhoPage, crio uma variável privada do tipo By chamada precoProduto e atribuída a By.cssSelector("span.price"). Crio mais uma variável privada do tipo By chamada tamanhoProduto e atribuída a By.xpath("//div[contains(@class,'product-line-grid-body')]//div[3]/span[contains(@class,'value')]"). Crio mais uma variável privada do tipo By chamada corProduto e atribuída a By.xpath("//div[contains(@class,'product-line-grid-body')]//div[4]/span[contains(@class,'value')]"). Crio mais uma variável privada do tipo By chamada input_quantidadeProduto e atribuída a By.cssSelector("input.js-cart-line-product-quantity"). Crio mais uma variável privada do tipo By chamada subtotalProduto e atribuída a By.cssSelector("span.product-price strong"). Crio mais uma variável privada do tipo By chamada numeroItensTotal e atribuída a
By.cssSelector("span.js-subtotal"). Crio mais uma variável privada do tipo By chamada subtotalTotal e atribuída a By.cssSelector("#cart-subtotal-products span.value"). Crio mais uma variável privada do tipo By chamada shippingTotal e atribuída a By.cssSelector("#cart-subtotal-shipping span.value"). Crio mais uma variável privada do tipo By chamada totalTaxExclTotal e atribuída a By.cssSelector("div.cart-summary-totals div.cart-summary-line:nth-child(1) span.value"). Crio mais uma variável privada do tipo By chamada totalTaxIncTotal e atribuída a By.cssSelector("div.cart-summary-totals div.cart-summary-line:nth-child(2) span.value"). Crio mais uma variável privada do tipo By chamada taxesTotal e atribuída a By.cssSelector("div.cart-summary-totals div.cart-summary-line:nth-child(3) span.value").

Testar Ir para o Carrinho - Parte 4

Para copiar os nomes das variáveis em seleção horizontal e vertical, uso Alt + Shift + A, seleciono as variáveis de forma vertical e horizontal, clico em Ctrl + C, depois em Alt + Shift + A e posiciono o cursor na área desejada para colar, clicando Ctrl + V. Crio então os métodos públicos do tipo String para obter os valores das variáveis, sempre acrescentando obter_ antes do nome de cada variável e retornando return driver.findElement(nomeProduto).getText() com o nome da variável na posição "nomeProduto" neste caso.

Testar Ir para o Carrinho - Parte 5

Continuando, criei a única exceção de retorno, a variável input_quantidadeProduto, que retornará  driver.findElement(input_quantidadeProduto).getAttribute("value"). Em HomePageTests, no teste IrParaCarrinho_InformacoesPersistidas(), imprimo no console as informações de produto e totais, dividindo em duas seções, "*** TELA DO CARRINHO***" e "** ITENS DE TOTAIS **"). Como alguns itens devem ter o cifrão removido e isso se repete algumas vezes, criei uma classe Funcoes em um pacote util dentro de src/main/java. Em Funcoes crio um método público estático do tipo Double, com um parâmetro, chamado removeCifraoDevolveDouble(String texto). Dentro dele, a variável texto do parâmetro removerá o cifrão com texto.replace("$", "") e o retornará já convertido com Double.parseDouble(texto). Também crio um método público estático do tipo int, com um parâmetro, chamado removeTextoItemsDevolveInt(String texto). Dentro dele, a variável texto do parâmetro removerá a palavra items com texto.replace("items", "") e o retornará já convertido com Integer.parseInt(texto). Em HomePageTests, importo a nova classe. Faço a validação dos itens aproveitando para seguir boas práticas de refatoração, deixando as variáveis para resultados obtidos das asserções instanciadas acima dos testes. Todas as variáveis começam com o prefixo esperado_. Criei então as asserções com assertThat, copiando o resultado esperado das declarações de impressão no console logo acima e o resultado obtido das variáveis criadas acima do teste.

Ir Para Check Out - Parte 1

Para fazer o checkout é necessário ter um endereço cadastrado no site, então cadastrei um endereço fake e depois inspecionei o botão Proceed to checkout para mapear o elemento. Em CarrinhoPage criei uma variável privada do tipo By chamada botaoProceedToChekcout atribuída a By.cssSelector("a.btn-primary"). Criei também um método público do tipo CheckoutPage chamado clicarBotaoProceedToCheckout() com um driver.findElement(botaoProceedToCheckout).click() que retorna um novo CheckoutPage(driver). Em HomePageTests criei mais uma anotação @Test com um método público sem retorno chamado testIrParaCheckout_FreteMeioPagamentoEnderecoListadosOk(). Faço a chamada do método testIrParaCarrinho_InformacoesPersistidas(). Removi CarrinhoPage carrinhoPage de dentro do outro método para reaproveitá-lo. Criei a variável checkoutPage e atribuí ao método carrinhoPage.clicarBotaoProceedToCheckout(). Instanciei fora do teste a variável checkoutPage do tipo 
CheckoutPage. Criei então uma classe CheckoutPage no pacote src/main/java/pages. Dentro da classe criei uma variável privada do tipo WebDriver chamada driver e um construtor para ela. Em HomePageTests importo a nova classe. No site, mapeio o elemento desejado e em CheckoutPage criei uma variável privada do tipo By chamada totalTaxIncTotal atribuída a By.cssSelector("div.cart-total span.value") (ou copio as mesmas variáveis de CarrinhoPage atribuindo aos elementos mapeados). Criei também um método público do tipo String chamado obter_totalTaxIncTotal() que retorna o texto com  driver.findElement(totalTaxIncTotal).getText(). Em HomePageTests crio a asserção com assertTrue com resultado esperado do método checkoutPage.obter_nomeCliente().startsWith(esperado_nomeCliente)). Para complementá-lo, crio uma asserção do tipo assertThat que tem o resultado esperado de Funcoes.removeCifraoDevolveDouble(checkoutPage.obter_totalTaxIncTotal()) e obtido de esperado_totalTaxIncTotal, para remover o cifrão.

Ir Para Check Out - Parte 2

Em CheckoutPage criei uma variável privada do tipo By chamada nomeCliente atribuída a  By.cssSelector("div.address"). Criei também o método público do tipo String chamado obter_nomeCliente() que retorna driver.findElement(nomeCliente).getText(). Criei então a variável privada do tipo By chamada botaoContinueAddress atribuída a By.name("confirm-addresses"). E criei um método público sem retorno chamado clicarBotaoContinueAddress() com driver.findElement(botaoContinueAddress).click().
Em HomePageTests, no teste testIrParaCheckout_FreteMeioPagamentoEnderecoListadosOk(), 
chamo o método checkoutPage.clicarBotaoContinueAddress() para clicar no botão Continue. Na página de checkout inspeciono o elemento que vem na sequência do teste e defini um teste para validar o valor de envio. Em CheckoutPage, defino uma variável privada do tipo By chamada shippingValor atribuída a  By.cssSelector("span.carrier-price"). Criei o método público do tipo String chamado  obter_shippingValor() retornando driver.findElement(shippingValor).getText() para obter o texto dela. Em Funcoes, criei um método público estático do tipo String, com parâmetros, chamado removeTexto(String texto, String textoParaRemover) para remover o texto indesejado usando texto = texto.replace(textoParaRemover, "") e retornando texto.
Em HomePageTests, no teste testIrParaCheckout_FreteMeioPagamentoEnderecoListadosOk(),  criei uma variável do tipo
String chamada encontrado_shippingValor atribuída a checkoutPage.obter_shippingValor(), uma variável encontrado_shippingValor atribuída a Funcoes.removeTexto(encontrado_shippingValor, " tax excl.") e uma variável do tipo Double chamada encontrado_shippingValor_Double atribuída a Funcoes.removeCifraoDevolveDouble(encontrado_shippingValor).
Criei a asserção assertThat(encontrado_shippingValor_Double, is(esperado_shippingTotal)). Em CheckoutPage
criei a variável privada do tipo By chamada botaoContinueShipping atribuída a  By.name("confirmDeliveryOption") e um método público sem retorno chamado  clicarBotaoContinueShipping() com	driver.findElement(botaoContinueShipping).click() para clicar no botão. Em HomePageTests, no teste testIrParaCheckout_FreteMeioPagamentoEnderecoListadosOk(), chamei o método checkoutPage.clicarBotaoContinueShipping(). Para fazer o debug do teste, criei um brakpoint em BaseTests na linha driver.quit(), que é a última etapa do teste e rodo como modo debug.

Ir Para Check Out - Parte 3

Em CheckoutPage criei a variável privada do tipo By chamada radioPayByCheck atribuída a By.id("payment-option-1") para mapear o primeiro método de pagamento e um método público sem retorno chamado selecionarRadioPayByCheck() com 	driver.findElement(radioPayByCheck).click(). Também criei a variável privada do tipo By chamada amountPayByCheck atribuída a By.cssSelector("#payment-option-1-additional-information > section> dl > dd:nth-child(2)") para mapear o valor. Criei o método público do tipo String chamado obter_amountPayByCheck() retornando driver.findElement(amountPayByCheck).getText() para obter o valor. 
Em HomePageTests, no teste testIrParaCheckout_FreteMeioPagamentoEnderecoListadosOk(), chamo o método checkoutPage.selecionarRadioPayByCheck(). 
Criei uma variável do tipo 
String chamada encontrado_amountPayByCheck atribuída a  checkoutPage.obter_amountPayByCheck(), uma variável encontrado_amountPayByCheck aytibuída a  Funcoes.removeTexto(encontrado_amountPayByCheck, " (tax incl.)") e uma variável do tipo Double chamada encontrado_amountPayByCheck_Double atribuída a  Funcoes.removeCifraoDevolveDouble(encontrado_amountPayByCheck). Criei a asserção com assertThat com o resultado esperado de encontrado_amountPayByCheck_Double e obtido de is(esperado_totalTaxIncTotal)). 
Em CheckoutPage criei a variável privada do tipo By chamada checkboxIAgree atribuída a By.id("conditions_to_approve[terms-and-conditions]"), um método público sem retorno chamado selecionarCheckboxIAgree() com driver.findElement(checkboxIAgree).click() para clicar e um método público do tipo boolean chamado estaSelecionadoCheckboxIAgree() retornando driver.findElement(checkboxIAgree).isSelected() para ter certeza de que a caixa de seleção está selecionada. 
Em HomePageTests, no teste testIrParaCheckout_FreteMeioPagamentoEnderecoListadosOk(), chamei o método checkoutPage.selecionarCheckboxIAgree() e fiz uma asserção usando assertTrue com o resultado esperado de  checkoutPage.estaSelecionadoCheckboxIAgree()).

Finalizar Pedido - Parte 1

Em HomePageTests, crio uma nova anotação @Test e um método público sem retorno chamado testFinalizarPedido_pedidoFinalizadoComSucesso(). Dentro dele, chamei testIrParaCheckout_FreteMeioPagamentoEnderecoListadosOk(). No site, mapeio o elemento do botão de confirmação de pagamento. Em CheckoutPage criei a variável privada do tipo By chamada botaoConfirmaPedido atribuída a By.cssSelector("#payment-confirmation button"), além de um método público do tipo PedidoPage chamado clicarBotaoConfirmaPedido() com driver.findElement(botaoConfirmaPedido).click() que retorna um novo PedidoPage(driver),
para clicar o botão. Em HomePageTests, no teste  testFinalizarPedido_pedidoFinalizadoComSucesso() criei uma variável do tipo PedidoPage chamada pedidoPage e atribuída ao método checkoutPage.clicarBotaoConfirmaPedido(). Criei uma nova classe PedidoPage com uma variável privada do tipo WebDriver chamada driver e seu construtor. No site, mapeei o elemento da mensagem de pedido confirmado e criei uma variável privada do tipo By chamada textoPedidoConfirmado atribuída a By.cssSelector("#content-hook_order_confirmation h3"). Criei um método público do tipo String chamado  obter_textoPedidoConfirmado() que retorna driver.findElement(textoPedidoConfirmado).getText() para ter o texto de pedido confirmado. Em HomePageTests, no teste testFinalizarPedido_pedidoFinalizadoComSucesso() criei uma asserção do tipo assertTrue para validar pedidoPage.obter_textoPedidoConfirmado().endsWith("YOUR ORDER IS CONFIRMED")). 

Finalizar Pedido - Parte 2

Em PedidoPage criei uma variável privada do tipo By chamada email e atribuída a By.cssSelector("#content-hook_order_confirmation p") depois de mapear o elemento no site. Criei também um método público do tipo String chamado obter_email(). Dentro dele criei uma variável do tipo String chamada texto atribuída a  driver.findElement(email).getText() para obter o texto. Removo as partes da mensagem que não interessam usando a função removeTexto com os atributos (texto, "An email has been sent to the ") e (texto, " address.") e retorno a variável texto. Criei uma variável privada do tipo By chamada totalProdutos atribuída a By.cssSelector("div.order-confirmation-table div.order-line div.row div.bold") 
depois de mapear o elemento no site. Criei um método público do tipo Double chamado  obter_totalProdutos() que retorna Funcoes.removeCifraoDevolveDouble(driver.findElement(totalProdutos).getText() com o valor sem cifrão. Depois de mapear no site, crio mais uma variável privada do tipo By chamada totalTaxIncl atribuída a  By.cssSelector("div.order-confirmation-table table tr.total-value td:nth-child(2)"). Criei um método público do tipo Double chamado  obter_totalTaxIncl() que retorna  Funcoes.removeCifraoDevolveDouble(driver.findElement(totalTaxIncl).getText()). Criei uma última variável privada do tipo By chamada metodoPagamento atribuída a  By.cssSelector("#order-details ul li:nth-child(2)"). Criei o último método público do tipo String chamado obter_metodoPagamento() que retorna Funcoes.removeTexto(driver.findElement(metodoPagamento).getText(), "Payment method: Payments by "). Em HomePageTests, no teste testFinalizarPedido_pedidoFinalizadoComSucesso() criei uma asserção do tipo assertThat para validar que o pedidoPage.obter_email() corresponda a is("sheila@teste.com"). Também incluo uma asserção do tipo assertThat para validar que pedidoPage.obter_totalProdutos() corresponda a is(esperado_subtotalProduto). Também incluo uma asserção do tipo assertThat para validar que pedidoPage.obter_totalTaxIncl() corresponda a is(esperado_totalTaxIncTotal). Por último, incluo uma asserção do tipo assertThat para validar que pedidoPage.obter_metodoPagamento() corresponda a is("check").

Solução de Problemas: Sincronismo

Um dos problemas que podem acontecer na automação de testes web é o sincronismo, que acontece por conta da coordenação no tempo da ocorrência de ações e pode causar exceções do tipo NoSuchElementException, porque o elemento ainda não está presente no DOM no momento do teste. As causas para isso são a programação de eventos assíncronos, lentidão na rede ou lentidão no processamento. Para resolver esse problema usamos esperas, que podem ser do tipo implícito, explícito ou fluent wait. A espera implícita é usada em casos gerais quando a  presença do elemento é atrasada pela criação de um modal, por exemplo. Um caso de uso de espera implícita é driver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS), que vai fazer todos os comandos findElement(s) do driver esperarem até 10 segundos para o elemento ser encontrado. O ideal é que essa espera em produção não seja superior a 3 segundos. 
A espera explícita pode ser usada no caso de elementos ainda não estarem visíveis no site e usa o elemento WebDriverWait, criando-se uma variável para recebê-lo: 		WebDriverWait wait = new WebDriverWait(driver, 10). É preciso definir as condições de espera, como no exemplo wait.until(ExpectedConditions.visibilityOfElementLocated(mensagemProdutoAdicionado)). A espera do tipo Fluent Wait vai fazer o polling, que é a verificação em frequência determinada em que ele vai ficar ignorando a exceção, por exemplo a cada um segundo, até que a condição que precisamos seja satisfeita. Um exemplo do FluentWait é, que precisa ser craido de forma similar ao WebDriverWait:
FluentWait fluentWait = new FluentWait(driver).withTimeout(Duration.ofSeconds(10)).pollingEvery(Duration.ofSeconds(1)).ignoring(NoSuchElementException.class),
Determinamos então a duração total da espera, o tempo entre cada verificação e a exceção a ser ignorada para que o teste não seja interrompido até que a condição seja satisfeita. É preciso também definir as condições específicas com fluentWait.until(ExpectedConditions.visibilityOfElementLocated(mensagemProdutoAdicionado)). 
As esperas ajudam o teste a ficar estável.

Solução de Problemas - Programação Exótica

A programação exótica é a maneira de programar que dificulta o entendimento e a manutenção dos testes. Isso acontece pela falta de conhecimento dos padrões de desenvolvimento e causa dificuldades como o baixo reaproveitamento de código, sua manutenção e entendimento. A solução é o uso de boas práticas de desenvolvimento, que usem nomes representativos para variáveis, classes e métodos. funcionalidades específicas, tamanho razoável e design patterns. Uma sugestão específica para automação de testes é o uso de design patterns como Page Objects, que separa elementos da tela em páginas, fora dos testes em si e o Screenplay. Outra sugestão é o uso de frameworks, como o JUnit e o TestNG, que são  conjuntos de bibiotecas e executores de testes que facilitam a escrita e execução do testes, padronizando o código. Separar página e testes Métodos de teste Classes de teste Classe base de teste
